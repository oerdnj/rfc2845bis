<?xml version="1.0"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<?rfc tocappendix="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="3"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<?rfc comments="no" ?>
<?rfc inline="yes" ?>

<rfc category="std" docName="draft-xxxx-dnsop-rfc2845-bis" ipr="trust200902">

  <front>
    <title abbrev="DNS TSIG">Secret Key Transaction Authentication for DNS (TSIG)</title>

    <author fullname="Paul Vixie" initials="P." surname="Vixie">
      <organization abbrev="ISC">Internet Software Consortium</organization>
      <address>
        <postal>
          <street>950 Charter Street</street>
          <city>Redwood City</city>
          <region>CA</region>
          <code>94063</code>
          <country>USA</country>
        </postal>
        <phone>+1 650 779 7001</phone>
        <email>vixie@isc.org</email>
      </address>
    </author>

    <author fullname="Olafur Gudmundsson" initials="O." surname="Gudmundsson">
      <organization>NAI Labs</organization>
      <address>
        <postal>
          <street>3060 Washington Road, Route 97</street>
          <city>Glenwood</city>
          <region>MD</region>
          <code>21738</code>
          <country>USA</country>
        </postal>
        <phone>+1 443 259 2389</phone>
        <email>ogud@tislabs.com</email>
      </address>
    </author>

    <author fullname="Donald E. Eastlake 3rd" initials="D." surname="Eastlake 3rd">
      <organization>Motorola</organization>
      <address>
        <postal>
          <street>140 Forest Avenue</street>
          <city>Hudson</city>
          <region>MA</region>
          <code>01749</code>
          <country>USA</country>
        </postal>
        <phone>+1 508 261 5434</phone>
        <email>dee3@torque.pothole.com</email>
      </address>
    </author>

    <author fullname="Brian Wellington" initials="B." surname="Wellington">
      <organization abbrev="Nominum">Nominum, Inc.</organization>
      <address>
        <postal>
          <street>950 Charter Street</street>
          <city>Redwood City</city>
          <region>CA</region>
          <code>94063</code>
          <country>USA</country>
        </postal>
        <phone>+1 650 779 6022</phone>
        <email>Brian.Wellington@nominum.com</email>
      </address>
    </author>

    <date/>
    <area>Operations and Management Area</area>
    <workgroup>Internet Engineering Task Force</workgroup>


    <abstract>
      <t>This protocol allows for transaction level authentication using
      shared secrets and one way hashing.  It can be used to authenticate
      dynamic updates as coming from an approved client, or to authenticate
      responses as coming from an approved recursive name server.</t>

      <t>No provision has been made here for distributing the shared
      secrets; it is expected that a network administrator will
      statically configure name servers and clients using some out
      of band mechanism such as sneaker-net until a secure automated
      mechanism for key distribution is available.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>The Domain Name System (DNS) <xref target="RFC1034"/>, <xref
      target="RFC1035"/> is a replicated hierarchical distributed
      database system that provides information fundamental to Internet
      operations, such as name &lt;=&gt; address translation and mail
      handling information.  DNS has recently been extended <xref
      target="RFC2535"/> to provide for data origin authentication, and
      public key distribution, all based on public key cryptography and
      public key based digital signatures.  To be practical, this form
      of security generally requires extensive local caching of keys and
      tracing of authentication through multiple keys and signatures to
      a pre-trusted locally configured key.</t>

      <t>One difficulty with the <xref target="RFC2535"/> scheme is that
      common DNS implementations include simple "stub" resolvers which
      do not have caches.  Such resolvers typically rely on a caching
      DNS server on another host.  It is impractical for these stub
      resolvers to perform general <xref target="RFC2535"/>
      authentication and they would naturally depend on their caching
      DNS server to perform such services for them.  To do so securely
      requires secure communication of queries and responses.  <xref
      target="RFC2535"/> provides public key transaction signatures to
      support this, but such signatures are very expensive
      computationally to generate.  In general, these require the same
      complex public key logic that is impractical for stubs.  This
      document specifies use of a message authentication code (MAC),
      specifically HMAC-MD5 (a keyed hash function), to provide an
      efficient means of point-to-point authentication and integrity
      checking for transactions.</t>

      <t>A second area where use of straight <xref target="RFC2535"/>
      public key based mechanisms may be impractical is authenticating
      dynamic update <xref target="RFC2136"/> requests.  <xref
      target="RFC2535"/> provides for request signatures but with <xref
      target="RFC2535"/> they, like transaction signatures, require
      computationally expensive public key cryptography and complex
      authentication logic.  Secure Domain Name System Dynamic Update
      (<xref target="RFC2137"/>) describes how different keys are used
      in dynamically updated zones.  This document's secret key based
      MACs can be used to authenticate DNS update requests as well as
      transaction responses, providing a lightweight alternative to the
      protocol described by <xref target="RFC2137"/>.</t>

      <t>A further use of this mechanism is to protect zone transfers.
      In this case the data covered would be the whole zone transfer
      including any glue records sent.  The protocol described by <xref
      target="RFC2535"/> does not protect glue records and unsigned
      records unless SIG(0) (transaction signature) is used.</t>

      <t>The authentication mechanism proposed in this document uses
      shared secret keys to establish a trust relationship between two
      entities.  Such keys must be protected in a fashion similar to
      private keys, lest a third party masquerade as one of the intended
      parties (forge MACs).  There is an urgent need to provide simple and
      efficient authentication between clients and local servers and this
      proposal addresses that need.  This proposal is unsuitable for
      general server to server authentication for servers which speak with
      many other servers, since key management would become unwieldy with
      the number of shared keys going up quadratically.  But it is suitable
      for many resolvers on hosts that only talk to a few recursive
      servers.</t>

      <t>A server acting as an indirect caching resolver -- a "forwarder"
      in common usage -- might use transaction-based authentication when
      communicating with its small number of preconfigured "upstream"
      servers.  Other uses of DNS secret key authentication and possible
      systems for automatic secret key distribution may be proposed in
      separate future documents.</t>

      <t>New Assigned Numbers:</t>

      <t>RRTYPE = TSIG (250)<vspace/>
      ERROR = 0..15 (a DNS RCODE)<vspace/>
      ERROR = 16 (BADSIG)<vspace/>
      ERROR = 17 (BADKEY)<vspace/>
      ERROR = 18 (BADTIME)</t>

      <t> The key words "MUST", "REQUIRED", "SHOULD", "RECOMMENDED",
      and "MAY" in this document are to be interpreted as described in
      <xref target="RFC2119"/>.</t>
    </section>

    <section title="TSIG RR Format">
      <section title="TSIG RR Type">
        <t>To provide secret key authentication, we use a new RR
        type whose mnemonic is TSIG and whose type code is 250.
        TSIG is a meta-RR and MUST not be cached.  TSIG RRs are
        used for authentication between DNS entities that have
        established a shared secret key.  TSIG RRs are dynamically
        computed to cover a particular DNS transaction and are not
        DNS RRs in the usual sense.</t>
      </section>

      <section title="TSIG Calculation">
        <t>As the TSIG RRs are related to one DNS request/response,
        there is no value in storing or retransmitting them, thus the
        TSIG RR is discarded once it has been used to authenticate a DNS
        message.  The only message digest algorithm specified in this
        document is "HMAC- MD5" (see <xref target="RFC1321"/>, <xref
        target="RFC2104"/>).  The "HMAC-MD5" algorithm is mandatory to
        implement for interoperability.  Other algorithms can be
        specified at a later date.  Names and definitions of new
        algorithms MUST be registered with IANA.  All multi-octet
        integers in the TSIG record are sent in network byte order (see
        <xref target="RFC1035"/> 2.3.2).</t>
      </section>

      <section title="Record Format">
        <t><list style="hanging" hangIndent="6">

          <t hangText="NAME">The name of the key used in domain
          name syntax.  The name should reflect the names of the
          hosts and uniquely identify the key among a set of keys
          these two hosts may share at any given time.  If hosts
          A.site.example and B.example.net share a key, possibilities
          for the key name include &lt;id&gt;.A.site.example,
          &lt;id&gt;.B.example.net, and
          &lt;id&gt;.A.site.example.B.example.net.  It should be
          possible for more than one key to be in simultaneous use
          among a set of interacting hosts.  The name only needs
          to be meaningful to the communicating hosts but a meaningful
          mnemonic name as above is strongly recommended.
          <vspace/><vspace/> The name may be used as a local index
          to the key involved and it is recommended that it be
          globally unique.  Where a key is just shared between two
          hosts, its name actually only need only be meaningful to
          them but it is recommended that the key name be mnemonic
          and incorporate the resolver and server host names in
          that order.</t>

          <t hangText="TYPE">TSIG (250: Transaction SIGnature)</t>

          <t hangText="CLASS">ANY</t>

          <t hangText="TTL">0</t>

          <t hangText="RdLen">(variable)</t>

          <t hangText="RDATA"></t>
        </list></t>

        <texttable style="headers">
          <ttcol>Field Name</ttcol>
          <ttcol>Data Type</ttcol>
          <ttcol>Notes</ttcol>

          <c>Algorithm Name</c>
          <c>domain-name</c>
          <c>Name of the algorithm in domain name syntax.</c>

          <c>Time Signed</c>
          <c>u_int48_t</c>
          <c>Seconds since 1-Jan-70 UTC.</c>

          <c>Fudge</c>
          <c>u_int16_t</c>
          <c>Seconds of error permitted in Time Signed.</c>

          <c>MAC Size</c>
          <c>u_int16_t</c>
          <c>Number of octets in MAC.</c>

          <c>MAC</c>
          <c>octet stream</c>
          <c>Defined by Algorithm Name.</c>

          <c>Original ID</c>
          <c>u_int16_t</c>
          <c>Original message ID</c>

          <c>Error</c>
          <c>u_int16_t</c>
          <c>Expanded RCODE covering TSIG processing.</c>

          <c>Other Len</c>
          <c>u_int16_t</c>
          <c>Length, in octets, of Other Data.</c>

          <c>Other Data</c>
          <c>octet stream</c>
          <c>Empty unless Error == BADTIME</c>
        </texttable>
      </section>

      <section title="Example">
        <t><list style="hanging" hangIndent="6">
          <t hangText="NAME">HOST.EXAMPLE.</t>

          <t hangText="TYPE">TSIG</t>

          <t hangText="CLASS">ANY</t>

          <t hangText="TTL">0</t>

          <t hangText="RdLen">As appropriate</t>

          <t hangText="RDATA"></t>
        </list></t>

        <texttable style="headers">
          <ttcol>Field Name</ttcol>
          <ttcol>Contents</ttcol>

          <c>Algorithm Name</c>
          <c>SAMPLE-ALG.EXAMPLE.</c>

          <c>Time Signed</c>
          <c>853804800</c>

          <c>Fudge</c>
          <c>300</c>

          <c>MAC Size</c>
          <c>As appropriate</c>

          <c>MAC</c>
          <c>As appropriate</c>

          <c>Original ID</c>
          <c>As appropriate</c>

          <c>Error</c>
          <c>0 (NOERROR)</c>

          <c>Other Len</c>
          <c>0</c>

          <c>Other Data</c>
          <c>Empty</c>
        </texttable>
      </section>
    </section>

    <section title="Protocol Operation">

      <section title="Effects of adding TSIG to outgoing message">
        <t>Once the outgoing message has been constructed, the keyed
        message digest operation can be performed.  The resulting
        message digest will then be stored in a TSIG which is
        appended to the additional data section (the ARCOUNT is
        incremented to reflect this).  If the TSIG record cannot
        be added without causing the message to be truncated, the
        server MUST alter the response so that a TSIG can be included.
        This response consists of only the question and a TSIG
        record, and has the TC bit set and RCODE 0 (NOERROR).  The
        client SHOULD at this point retry the request using TCP
        (per <xref target="RFC1035"/> 4.2.2).</t>
      </section>

      <section title="TSIG processing on incoming messages">
        <t>If an incoming message contains a TSIG record, it MUST
        be the last record in the additional section.  Multiple
        TSIG records are not allowed.  If a TSIG record is present
        in any other position, the packet is dropped and a response
        with RCODE 1 (FORMERR) MUST be returned.  Upon receipt of
        a message with a correctly placed TSIG RR, the TSIG RR is
        copied to a safe location, removed from the DNS Message,
        and decremented out of the DNS message header's ARCOUNT.
        At this point the keyed message digest operation is performed.
        If the algorithm name or key name is unknown to the recipient,
        or if the message digests do not match, the whole DNS message
        MUST be discarded.  If the message is a query, a response
        with RCODE 9 (NOTAUTH) MUST be sent back to the originator
        with TSIG ERROR 17 (BADKEY) or TSIG ERROR 16 (BADSIG).  If
        no key is available to sign this message it MUST be sent
        unsigned (MAC size == 0 and empty MAC).  A message to the
        system operations log SHOULD be generated, to warn the
        operations staff of a possible security incident in progress.
        Care should be taken to ensure that logging of this type
        of event does not open the system to a denial of service
        attack.</t>
      </section>

      <section title="Time values used in TSIG calculations">
        <t>The data digested includes the two timer values in the
        TSIG header in order to defend against replay attacks.  If
        this were not done, an attacker could replay old messages
        but update the "Time Signed" and "Fudge" fields to make the
        message look new.  This data is named "TSIG Timers", and
        for the purpose of digest calculation they are invoked in
        their "on the wire" format, in the following order: first
        Time Signed, then Fudge.  For example:</t>

        <texttable style="headers">
          <ttcol>Field Name</ttcol>
          <ttcol>Value</ttcol>
          <ttcol>Wire Format</ttcol>
          <ttcol>Meaning</ttcol>

          <c>Time Signed</c>
          <c>853804800</c>
          <c>00 00 32 e4 07 00</c>
          <c>Tue Jan 21 00:00:00 1997</c>

          <c>Fudge</c>
          <c>300</c>
          <c>01 2C</c>
          <c>5 minutes</c>
        </texttable>
      </section>

      <section title="TSIG Variables and Coverage">
        <t>When generating or verifying the contents of a TSIG
        record, the following data are digested, in network byte
        order or wire format, as appropriate:</t>

        <section title="DNS Message">
          <t>A whole and complete DNS message in wire format, before
          the TSIG RR has been added to the additional data section
          and before the DNS Message Header's ARCOUNT field has
          been incremented to contain the TSIG RR.  If the message
          ID differs from the original message ID, the original
          message ID is substituted for the message ID.  This could
          happen when forwarding a dynamic update request, for
          example.</t>
        </section>

        <section title="TSIG Variables">
          <texttable style="headers">
            <ttcol>Source</ttcol>
            <ttcol>Field Name</ttcol>
            <ttcol>Notes</ttcol>

            <c>TSIG RR</c>
            <c>NAME</c>
            <c>Key name, in canonical wire format</c>

            <c>TSIG RR</c>
            <c>CLASS</c>
            <c>(Always ANY in the current specification)</c>

            <c>TSIG RR</c>
            <c>TTL</c>
            <c>(Always 0 in the current specification)</c>

            <c>TSIG RDATA</c>
            <c>Algorithm Name</c>
            <c>in canonical wire format</c>

            <c>TSIG RDATA</c>
            <c>Time Signed</c>
            <c>in network byte order</c>

            <c>TSIG RDATA</c>
            <c>Fudge</c>
            <c>in network byte order</c>

            <c>TSIG RDATA</c>
            <c>Error</c>
            <c>in network byte order</c>

            <c>TSIG RDATA</c>
            <c>Other Len</c>
            <c>in network byte order</c>

            <c>TSIG RDATA</c>
            <c>Other Data</c>
            <c>exactly as transmitted</c>
          </texttable>

          <t>The RR RDLEN and RDATA MAC Length are not included in the hash
          since they are not guaranteed to be knowable before the MAC is
          generated.</t>

          <t>The Original ID field is not included in this section,
          as it has already been substituted for the message ID in
          the DNS header and hashed.</t>

          <t>For each label type, there must be a defined "Canonical
          wire format" that specifies how to express a label in an
          unambiguous way.  For label type 00, this is defined in <xref
          target="RFC2535"/>, for label type 01, this is defined in
          <xref target="RFC2673"/>.  The use of label types other than
          00 and 01 is not defined for this specification.</t>
        </section>

        <section title="Request MAC">
          <t>When generating the MAC to be included in a response,
          the request MAC must be included in the digest.  The
          request's MAC is digested in wire format, including the
          following fields:</t>

          <texttable style="headers">
            <ttcol>Field</ttcol>
            <ttcol>Type</ttcol>
            <ttcol>Description</ttcol>

            <c>MAC Length</c>
            <c>u_int16_t</c>
            <c>in network byte order</c>

            <c>MAC Data</c>
            <c>octet stream</c>
            <c>exactly as transmitted</c>
          </texttable>
        </section>
      </section>

      <section title="Padding">
        <t>Digested components are fed into the hashing function as a
        continuous octet stream with no interfield padding.</t>
      </section>
    </section>

    <section title="Protocol Details">

      <section title="TSIG generation on requests">
        <t>Client performs the message digest operation and appends a TSIG
        record to the additional data section and transmits the request to
        the server.  The client MUST store the message digest from the
        request while awaiting an answer.  The digest components for a
        request are:</t>

        <t><list style="empty">
          <t>DNS Message (request)<vspace/>
             TSIG Variables (request)</t>
        </list></t>

        <t>Note that some older name servers will not accept requests with
        a nonempty additional data section.  Clients SHOULD only attempt
        signed transactions with servers who are known to support TSIG and
        share some secret key with the client -- so, this is not a problem
        in practice.</t>
      </section>

      <section title="TSIG on Answers">
        <t>When a server has generated a response to a signed request, it
        signs the response using the same algorithm and key.  The server
        MUST not generate a signed response to an unsigned request.  The
        digest components are:</t>

        <t><list style="empty">
          <t>Request MAC<vspace/>
             DNS Message (response)<vspace/>
             TSIG Variables (response)</t>
        </list></t>
      </section>

      <section title="TSIG on TSIG Error returns">
        <t>When a server detects an error relating to the key or MAC, the
        server SHOULD send back an unsigned error message (MAC size == 0
        and empty MAC).  If an error is detected relating to the TSIG
        validity period, the server SHOULD send back a signed error message.
        The digest components are:</t>

        <t><list style="empty">
          <t>Request MAC (if the request MAC validated)<vspace/>
             DNS Message (response)<vspace/>
             TSIG Variables (response)</t>
        </list></t>

        <t>The reason that the request is not included in this digest in
        some cases is to make it possible for the client to verify the
        error.  If the error is not a TSIG error the response MUST be
        generated as specified in [4.2].</t>
      </section>

      <section title="TSIG on TCP connection">
        <t>A DNS TCP session can include multiple DNS envelopes.  This is,
        for example, commonly used by zone transfer.  Using TSIG on such a
        connection can protect the connection from hijacking and provide
        data integrity.  The TSIG MUST be included on the first and last
        DNS envelopes.  It can be optionally placed on any intermediary
        envelopes.  It is expensive to include it on every envelopes, but
        it MUST be placed on at least every 100'th envelope.  The first
        envelope is processed as a standard answer, and subsequent messages
        have the following digest components:</t>

        <t><list style="empty">
          <t>Prior Digest (running)<vspace/>
             DNS Messages (any unsigned messages since the last TSIG)<vspace/>
             TSIG Timers (current message)</t>
        </list></t>

        <t>This allows the client to rapidly detect when the session has
        been altered; at which point it can close the connection and retry.
        If a client TSIG verification fails, the client MUST close the
        connection.  If the client does not receive TSIG records frequently
        enough (as specified above) it SHOULD assume the connection has
        been hijacked and it SHOULD close the connection.  The client SHOULD
        treat this the same way as they would any other interrupted transfer
        (although the exact behavior is not specified).</t>
      </section>

      <section title="Server TSIG checks">
        <t>Upon receipt of a message, server will check if there is a TSIG
        RR.  If one exists, the server is REQUIRED to return a TSIG RR in
        the response.  The server MUST perform the following checks in the
        following order, check KEY, check TIME values, check MAC.</t>

        <section title="KEY check and error handling">
          <t>If a non-forwarding server does not recognize the key
          used by the client, the server MUST generate an error
          response with RCODE 9 (NOTAUTH) and TSIG ERROR 17 (BADKEY).
          This response MUST be unsigned as specified in [4.3].
          The server SHOULD log the error.</t>
        </section>

        <section title="TIME check and error handling">
          <t>If the server time is outside the time interval specified
          by the request (which is: Time Signed, plus/minus Fudge),
          the server MUST generate an error response with RCODE 9
          (NOTAUTH) and TSIG ERROR 18 (BADTIME).  The server SHOULD
          also cache the most recent time signed value in a message
          generated by a key, and SHOULD return BADTIME if a message
          received later has an earlier time signed value.  A
          response indicating a BADTIME error MUST be signed by the
          same key as the request.  It MUST include the client's
          current time in the time signed field, the server's current
          time (a u_int48_t) in the other data field, and 6 in the
          other data length field.  This is done so that the client
          can verify a message with a BADTIME error without the
          verification failing due to another BADTIME error.  The
          data signed is specified in [4.3].  The server SHOULD log
          the error.</t>
        </section>

        <section title="MAC check and error handling">
          <t>If a TSIG fails to verify, the server MUST generate
          an error response as specified in [4.3] with RCODE 9
          (NOTAUTH) and TSIG ERROR 16 (BADSIG).  This response MUST
          be unsigned as specified in [4.3].  The server SHOULD log
          the error.</t>
        </section>
      </section>

      <section title="Client processing of answer">
        <t>When a client receives a response from a server and
        expects to see a TSIG, it first checks if the TSIG RR is
        present in the response.  Otherwise, the response is treated
        as having a format error and discarded.  The client then
        extracts the TSIG, adjusts the ARCOUNT, and calculates the
        keyed digest in the same way as the server.  If the TSIG
        does not validate, that response MUST be discarded, unless
        the RCODE is 9 (NOTAUTH), in which case the client SHOULD
        attempt to verify the response as if it were a TSIG Error
        response, as specified in [4.3].  A message containing an
        unsigned TSIG record or a TSIG record which fails verification
        SHOULD not be considered an acceptable response; the client
        SHOULD log an error and continue to wait for a signed
        response until the request times out.</t>

        <section title="Key error handling">
          <t>If an RCODE on a response is 9 (NOTAUTH), and the
          response TSIG validates, and the TSIG key is different
          from the key used on the request, then this is a KEY
          error.  The client MAY retry the request using the key
          specified by the server.  This should never occur, as a
          server MUST NOT sign a response with a different key than
          signed the request.</t>
        </section>

        <section title="Time error handling">
          <t>If the response RCODE is 9 (NOTAUTH) and the TSIG ERROR
          is 18 (BADTIME), or the current time does not fall in the
          range specified in the TSIG record, then this is a TIME
          error.  This is an indication that the client and server
          clocks are not synchronized.  In this case the client
          SHOULD log the event.  DNS resolvers MUST NOT adjust any
          clocks in the client based on BADTIME errors, but the
          server's time in the other data field SHOULD be logged.</t>
        </section>

        <section title="MAC error handling">
          <t>If the response RCODE is 9 (NOTAUTH) and TSIG ERROR
          is 16 (BADSIG), this is a MAC error, and client MAY retry
          the request with a new request ID but it would be better
          to try a different shared key if one is available.  Client
          SHOULD keep track of how many MAC errors are associated
          with each key.  Clients SHOULD log this event.</t>
        </section>
      </section>

      <section title="Special considerations for forwarding servers">
        <t>A server acting as a forwarding server of a DNS message
        SHOULD check for the existence of a TSIG record.  If the name on
        the TSIG is not of a secret that the server shares with the
        originator the server MUST forward the message unchanged
        including the TSIG.  If the name of the TSIG is of a key this
        server shares with the originator, it MUST process the TSIG.  If
        the TSIG passes all checks, the forwarding server MUST, if
        possible, include a TSIG of his own, to the destination or the
        next forwarder.  If no transaction security is available to the
        destination and the response has the AD flag (see <xref
        target="RFC2535"/>), the forwarder MUST unset the AD flag before
        adding the TSIG to the answer.</t>
      </section>
    </section>

    <section title="Shared Secrets">
      <t>Secret keys are very sensitive information and all available
      steps should be taken to protect them on every host on which they
      are stored.  Generally such hosts need to be physically protected.
      If they are multi-user machines, great care should be taken that
      unprivileged users have no access to keying material.  Resolvers
      often run unprivileged, which means all users of a host would be
      able to see whatever configuration data is used by the resolver.</t>

      <t>A name server usually runs privileged, which means its
      configuration data need not be visible to all users of the host.
      For this reason, a host that implements transaction-based
      authentication should probably be configured with a "stub
      resolver" and a local caching and forwarding name server.  This
      presents a special problem for <xref target="RFC2136"/> which
      otherwise depends on clients to communicate only with a zone's
      authoritative name servers.</t>

      <t>Use of strong random shared secrets is essential to the
      security of TSIG.  See <xref target="RFC1750"/> for a discussion
      of this issue.  The secret should be at least as long as the keyed
      message digest, i.e. 16 bytes for HMAC-MD5 or 20 bytes for
      HMAC-SHA1.</t>
    </section>

    <section title="Security Considerations">
      <t>The approach specified here is computationally much less
      expensive than the signatures specified in <xref
      target="RFC2535"/>.  As long as the shared secret key is not
      compromised, strong authentication is provided for the last hop
      from a local name server to the user resolver.</t>

      <t>Secret keys should be changed periodically.  If the client host
      has been compromised, the server should suspend the use of all
      secrets known to that client.  If possible, secrets should be stored
      in encrypted form.  Secrets should never be transmitted in the clear
      over any network.  This document does not address the issue on how
      to distribute secrets. Secrets should never be shared by more than
      two entities.</t>

      <t>This mechanism does not authenticate source data, only its
      transmission between two parties who share some secret.  The
      original source data can come from a compromised zone master or
      can be corrupted during transit from an authentic zone master to
      some "caching forwarder."  However, if the server is faithfully
      performing the full <xref target="RFC2535"/> security checks, then
      only security checked data will be available to the client.</t>

      <t>A fudge value that is too large may leave the server open
      to replay attacks.  A fudge value that is too small may cause
      failures if machines are not time synchronized or there are unexpected
      network delays.  The recommended value in most situation is 300
      seconds.</t>
    </section>

    <section title="IANA Considerations">
      <t>IANA is expected to create and maintain a registry of algorithm
      names to be used as "Algorithm Names" as defined in Section 2.3.
      The initial value should be "HMAC-MD5.SIG-ALG.REG.INT".  Algorithm
      names are text strings encoded using the syntax of a domain name.
      There is no structure required other than names for different
      algorithms must be unique when compared as DNS names, i.e.,
      comparison is case insensitive.  Note that the initial value
      mentioned above is not a domain name, and therefore need not be a
      registered name within the DNS.  New algorithms are assigned using
      the IETF Consensus policy defined in RFC 2434. The algorithm name
      HMAC-MD5.SIG-ALG.REG.INT looks like a FQDN for historical reasons;
      future algorithm names are expected to be simple (i.e.,
      single-component) names.</t>

      <t>IANA is expected to create and maintain a registry of "TSIG Error
      values" to be used for "Error" values as defined in section 2.3.
      Initial values should be those defined in section 1.7.  New TSIG
      error codes for the TSIG error field are assigned using the IETF
      Consensus policy defined in RFC 2434.</t>
    </section>
  </middle>

  <back>
    <references title="References">
      <?rfc include="reference.RFC.1034.xml"?>
      <?rfc include="reference.RFC.1035.xml"?>
      <?rfc include="reference.RFC.1321.xml"?>
      <?rfc include="reference.RFC.1750.xml"?>
      <?rfc include="reference.RFC.2104.xml"?>
      <?rfc include="reference.RFC.2119.xml"?>
      <?rfc include="reference.RFC.2136.xml"?>
      <?rfc include="reference.RFC.2137.xml"?>
      <?rfc include="reference.RFC.2535.xml"?>
      <?rfc include="reference.RFC.2673.xml"?>
    </references>
  </back>

</rfc>
